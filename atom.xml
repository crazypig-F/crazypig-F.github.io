<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crazypig的博客</title>
  
  
  <link href="https://www.crazypig.top/atom.xml" rel="self"/>
  
  <link href="https://www.crazypig.top/"/>
  <updated>2022-01-08T07:51:03.000Z</updated>
  <id>https://www.crazypig.top/</id>
  
  <author>
    <name>crazypig</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回文链表</title>
    <link href="https://www.crazypig.top/2022/01/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.crazypig.top/2022/01/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-08T07:51:03.000Z</published>
    <updated>2022-01-08T07:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>难度简单</p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先利用快慢指针找出链表的中间结点，这里链表个数是奇数还是偶数需要分开讨论一下</li><li>将中间结点到链表最后进行反转</li><li>将前半段链表和反转后的链表比较，如果有不相同的元素返回false,全部都相同则返回true</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pre *ListNode</span><br><span class="line">curr := head</span><br><span class="line"><span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">next := curr.Next</span><br><span class="line">curr.Next = pre</span><br><span class="line">pre = curr</span><br><span class="line">curr = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">//得到链表的中间结点</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">slow := head.Next</span><br><span class="line">fast := head.Next.Next</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mid *ListNode</span><br><span class="line"><span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">mid = slow</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mid = slow.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从中间结点开始到链表末尾反转链表</span></span><br><span class="line">tail := reverseList(mid)</span><br><span class="line"><span class="comment">//比较前半段和反转后的后半段链表</span></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; tail != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head.Val != tail.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">head = head.Next</span><br><span class="line">tail = tail.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;234-回文链表&quot;&gt;&lt;a href=&quot;#234-回文链表&quot; class=&quot;headerlink&quot; title=&quot;234. 回文链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-l</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="链表" scheme="https://www.crazypig.top/tag/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="https://www.crazypig.top/2022/01/08/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.crazypig.top/2022/01/08/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-08T07:28:07.000Z</published>
    <updated>2022-01-08T07:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h1><p>难度简单</p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用三个临时变量改变结点的指向</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pre *ListNode</span><br><span class="line">curr := head</span><br><span class="line"><span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">next := curr.Next</span><br><span class="line">curr.Next = pre</span><br><span class="line">pre = curr</span><br><span class="line">curr = next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;206-反转链表&quot;&gt;&lt;a href=&quot;#206-反转链表&quot; class=&quot;headerlink&quot; title=&quot;206. 反转链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="链表" scheme="https://www.crazypig.top/tag/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>环形链表 II</title>
    <link href="https://www.crazypig.top/2022/01/08/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"/>
    <id>https://www.crazypig.top/2022/01/08/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</id>
    <published>2022-01-08T02:59:13.000Z</published>
    <updated>2022-01-08T02:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>难度中等</p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>快慢指针</p><ol><li><p>在环形链表的基础上，如果存在环，那么继续找出环的入口结点，如果不存在环则返回NULL</p></li><li><p>当快慢指针第一次相遇时，将快指针指向头结点，然后快慢指针同时每次向前走一步，当它们再次相遇时的结点就是环形链表的入口结点。</p></li><li><p>具体的推导如下图leetcode官方给出的题解</p><p><img src="http://cdn.crazypig.top/image-20220108105741031.png" alt="image-20220108105741031"></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">slow, fast := head.Next, head.Next.Next</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;142-环形链表-II&quot;&gt;&lt;a href=&quot;#142-环形链表-II&quot; class=&quot;headerlink&quot; title=&quot;142. 环形链表 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-lis</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="链表" scheme="https://www.crazypig.top/tag/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="中等" scheme="https://www.crazypig.top/tag/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>环形链表</title>
    <link href="https://www.crazypig.top/2022/01/08/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.crazypig.top/2022/01/08/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-08T02:38:39.000Z</published>
    <updated>2022-01-08T02:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>难度简单</p><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>快慢指针</p><ol><li>快慢两个指针同时在头结点，快指针每次走两步，慢指针每次走一步</li><li>快慢两个指针相遇说明有环，如果快指针到NULL还没有相遇则说明没环</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">slow, fast := head.Next, head.Next.Next</span><br><span class="line"><span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> slow == fast &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">slow = slow.Next</span><br><span class="line">fast = fast.Next.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;141-环形链表&quot;&gt;&lt;a href=&quot;#141-环形链表&quot; class=&quot;headerlink&quot; title=&quot;141. 环形链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="链表" scheme="https://www.crazypig.top/tag/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序数组</title>
    <link href="https://www.crazypig.top/2022/01/07/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://www.crazypig.top/2022/01/07/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-01-07T07:15:20.000Z</published>
    <updated>2022-01-07T07:15:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>难度简单</p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针</p><ol><li>m指针指向第一个数组有效数字末尾，n指针指向第二个数组有效数字末尾，k指针指向第一个数组最后</li><li>m指针指向的数比n数组指向的数大，则m指针指向的数添加到k指针的位置，m指针向前移动一个位置，k指针向前移动一个位置</li><li>反之，则n指针指向的数添加到k指针的位置，n指针向前移动一个位置，k指针向前移动一个位置</li><li>如果其中一个数组遍历完成，则将另一个数组的剩余元素逐个添加到k指针所指的位置</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">k := m + n - <span class="number">1</span></span><br><span class="line">m--; n--</span><br><span class="line"><span class="keyword">for</span> m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[m] &gt; nums2[n] &#123;</span><br><span class="line">nums1[k] = nums1[m]</span><br><span class="line">k--; m--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nums1[k] = nums2[n]</span><br><span class="line">k--; n--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        nums1[k] = nums1[m]</span><br><span class="line">        k--; m--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        nums1[k] = nums2[n]</span><br><span class="line">        k--; n--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(m+n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;88-合并两个有序数组&quot;&gt;&lt;a href=&quot;#88-合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;88. 合并两个有序数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-sort</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="双指针" scheme="https://www.crazypig.top/tag/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="数组" scheme="https://www.crazypig.top/tag/%E6%95%B0%E7%BB%84/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>移动零</title>
    <link href="https://www.crazypig.top/2022/01/07/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>https://www.crazypig.top/2022/01/07/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</id>
    <published>2022-01-07T06:44:15.000Z</published>
    <updated>2022-01-07T06:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h1><p>难度简单</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针</p><ol><li>左指针指向已经处理好的数组尾部，右指针指向左指针后面第一个不是0的元素</li><li>将右指针的值赋值给左指针，左右指针都加1</li><li>右指针遍历完数组后将左指针后面的元素都赋值为0</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> j &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[j] == <span class="number">0</span> &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[j] != <span class="number">0</span> &#123;</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;283-移动零&quot;&gt;&lt;a href=&quot;#283-移动零&quot; class=&quot;headerlink&quot; title=&quot;283. 移动零&quot;&gt;&lt;/a&gt;283. 移动零&lt;/h1&gt;&lt;p&gt;难度简单&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="双指针" scheme="https://www.crazypig.top/tag/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="数组" scheme="https://www.crazypig.top/tag/%E6%95%B0%E7%BB%84/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>删除链表中重复元素</title>
    <link href="https://www.crazypig.top/2022/01/06/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://www.crazypig.top/2022/01/06/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2022-01-06T03:18:09.000Z</published>
    <updated>2022-01-06T03:18:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>难度简单</p><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断下一个结点是否和当前结点相等，如果相等，当前结点就指向下一个结点的下一个结点</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">int</span></span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    p := head</span><br><span class="line">    q := p.Next</span><br><span class="line">    <span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> q.Val == p.Val &#123;</span><br><span class="line">            p.Next = q.Next</span><br><span class="line">            q = q.Next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = p.Next</span><br><span class="line">            q = q.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;83-删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#83-删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;83. 删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="链表" scheme="https://www.crazypig.top/tag/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>爬楼梯</title>
    <link href="https://www.crazypig.top/2022/01/05/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>https://www.crazypig.top/2022/01/05/%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2022-01-05T08:59:54.000Z</published>
    <updated>2022-01-05T08:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>难度简单</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h2 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h2><p>$$<br>f(n) = \begin{cases}<br>1 &amp; n = 1 \<br>2 &amp; n = 2 \<br>f(n-1) + f(n-2) &amp; n \geq 3<br>\end{cases}<br>$$</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">c := a + b</span><br><span class="line">a, b = b, c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度O(n)</p><p>空间复杂度O(1)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. 爬楼梯&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot;&gt;70. 爬楼梯</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.crazypig.top/tag/leetcode/"/>
    
    <category term="递归" scheme="https://www.crazypig.top/tag/%E9%80%92%E5%BD%92/"/>
    
    <category term="简单" scheme="https://www.crazypig.top/tag/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基本概念</title>
    <link href="https://www.crazypig.top/2022/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.crazypig.top/2022/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-01-05T07:11:48.000Z</published>
    <updated>2022-01-05T07:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li>并行指两个或多个事件在同一时刻发生</li><li>并发指两个或多个事件在同一时间间隔发生</li></ul><h2 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h2><ul><li>异步性就是描述进程以不可预知的速度走走停停、何时开始、何时暂停、何时结束不可预知的性质</li></ul><h2 id="同步与异步-阻塞与非阻塞"><a href="#同步与异步-阻塞与非阻塞" class="headerlink" title="同步与异步 阻塞与非阻塞"></a>同步与异步 阻塞与非阻塞</h2><ol><li>老王用水壶煮水，并且<em>站在那里</em>，<em>不管水开没开，每隔一定时间看看水开了没</em>。－<strong>同步阻塞</strong></li><li>老王还是用水壶煮水，不再傻傻的站在那里看水开，<em>跑去寝室上网</em>，<em>但是还是会每隔一段时间过来看看水开了没有，水没有开就走人</em>。－<strong>同步非阻塞</strong></li><li>老王这次使用高大上的响水壶来煮水，<em>站在那里</em>，<em>但是不会再每隔一段时间去看水开，而是等水开了，水壶会自动的通知他</em>。－<strong>异步阻塞</strong></li><li>老王还是使用响水壶煮水，<em>跑到客厅上网去</em>，等着响水壶<em>自己把水煮熟了以后通知他</em>。－<strong>异步非阻塞</strong></li></ol><ul><li><p><strong>同步和异步</strong></p><p>同步就是烧开水，需要自己去轮询（每隔一段时间去看看水开了没），异步就是水开了，然后水壶会通知你水已经开了，你可以回来处理这些开水了。<br>同步和异步是相对于操作结果来说，会不会等待结果返回。</p></li><li><p><strong>阻塞和非阻塞</strong></p><p>阻塞就是说在煮水的过程中，你不可以去干其他的事情，非阻塞就是在同样的情况下，可以同时去干其他的事情。阻塞和非阻塞是相对于线程是否被阻塞。</p></li></ul><p>其实，这两者存在本质的区别，它们的修饰对象是不同的。阻塞和非阻塞是指进程访问的数据如果尚未就绪，进程是否需要等待，简单说这相当于函数内部的实现区别，也就是未就绪时是直接返回还是等待就绪。<br>而同步和异步是指访问数据的机制,同步一般指主动请求并等待I/O操作完毕的方式,当数据就绪后在读写的时候必须阻塞,异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统基本概念&quot;&gt;&lt;a href=&quot;#操作系统基本概念&quot; class=&quot;headerlink&quot; title=&quot;操作系统基本概念&quot;&gt;&lt;/a&gt;操作系统基本概念&lt;/h1&gt;&lt;h2 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.crazypig.top/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://www.crazypig.top/tag/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://www.crazypig.top/2022/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://www.crazypig.top/2022/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-01-05T07:08:08.000Z</published>
    <updated>2022-01-05T07:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些<em>不相交集合</em>的合并问题。一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先等。</p><p>并查集的基本操作有三个：</p><ol><li>makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。</li><li>unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。</li><li>find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。</li></ol><p>并查集的逻辑结构用树来表示</p><p><img src="http://cdn.crazypig.top/image-20211219195413491.png" alt="image-20211219195413491"></p><p>用它的物理结构用树的双亲表示法来存储</p><table><thead><tr><th>数组下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>元素</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td></tr><tr><td>双亲下标</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>-1</td><td>4</td><td>5</td></tr></tbody></table><p>并查集的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100<span class="comment">//宏定义树中结点的最大数量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;<span class="comment">//宏定义树结构中数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Snode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//树中结点的数据类型</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//结点的父结点在数组中的位置下标</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PTNode tnode[MAX_SIZE];<span class="comment">//存放树中所有结点</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//根的位置下标和结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><p>并查集并操作的优化：每次将小树并到大树中去，可以减少合并后的树的层数，提高性能</p><p>并查集查的优化：路径压缩，路径压缩就是在每次查找时，令查找路径上的每个节点都直接指向根节点</p><p><img src="http://cdn.crazypig.top/image-20211219200913080.png" alt="image-20211219200913080"></p><p>并查集的应用</p><ol><li>求图的连通分量</li><li>求图中是否有环</li><li>最小生成树的 Kruskal 算法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些&lt;em&gt;不相交集合&lt;/em&gt;的合并问题。一</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://www.crazypig.top/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://www.crazypig.top/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="并查集" scheme="https://www.crazypig.top/tag/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
